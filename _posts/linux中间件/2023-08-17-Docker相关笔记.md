---
layout: post
title: docker 相关笔记
description: docker 相关笔记
lead: 
comments: true
categories: 
  - note
---

- toc
{: toc }

## 安装

## 搭建docker hub私服

###  运行服务

```sh
# 拉取镜像
> docker pull registry:2
# 运行image
> docker run -d \
	# 端口映射
 -p 5000:5000 \
 	# 映射数据卷
 -v /usr/local/registry:/var/lib/registry \
 	# 重启策略
 --restart=always \
 	# 容器名
 --name registry \
```

### 验证

```sh
# 拉取一个供验证的镜像
> docker pull busybox
# 镜像打标签
> docker tag busybox localhost:5000/bosybox:v1.0
# 登录
> docker login -u admin -p Harbor12345 172.19.166.202
# 推送镜像至私服
> docker push localhost:5000/bosybox:v1.0
# 从私服拉取
> docker pull localhost:5000/bosybox:v1.0	
# 查看远程仓库有哪些镜像
> curl http://localhost:5000/v2/_catalog
```

### 配置完https后运行

```sh
docker run -d \
  -p 5000:5000 \
  -v /mnt/soft/docker-repositry:/var/lib/registry \
  -v /mnt/soft/ssl:/certs \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/cicd-server.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/cicd-server.key \
  --restart=always \
  --name registry \
  registry:2
```









## windows下docker访问宿主机服务

>  网络访问 https://docs.docker.com/desktop/windows/networking/

```
localhost=host.docker.internal
```





## windows下docker启动报错

执行命令 

```bash
netsh winsock reset
```





## 特权容器

> docker 容器如果想要访问宿主机资源的话，需要再docker 容器启动运行配置 `-- privileged = true`

### -- privileged 作用

是否允许Docker运行的容器拥有root权限；

### 配置示例

**docker run 命令**

```sh
docker run -- privileged=true --name ${docker_name} -p xxxx:xxxx -d ${docker_image}
```

**docker compose 配置**

privileged 配置须在数据卷配置`volumes` 之后

```yaml
version: "3.9"
services:
  db:
    image: postgres:9.4
    volumes:
      - db-data:/var/lib/postgresql/data
    privileged: true
    networks:
      - backend
    deploy:
      placement:
        constraints: [node.role == manager]

```

### 使用宿主机资源

```sh
nsenter --mount=${容器映射的宿主机服务`/proc/1/ns/mnt`} sh -c '${需执行得shell命令}'

例如：
数据卷配置：-v /host/proc/:/proc
执行语句：> nsenter --mount=/host/proc/1/ns/mnt sh -c 'ls /root'
```







## 命令

### docker命令：

```sh
	docker version：查看版本
	docker info ：查看信息
	docker image prune -a -f：清除镜像
	docker images：查看本机镜像
	docker ps：查看当前启动的容器
	docker ps -a：查看所有的容器
	docker run -it 仓库源：标签 /bin/bash ：启动容器并进入bash交互终端
	docker start 容器ID：启动容器
	docker stop 容器ID：优雅的停止容器
	docker rm	容器ID:删除容器
	docker rm `docker ps -a|grep Exited|awk '{print $1}'`	：删除docker中已经停止的所有容器
	docker kill 容器id：直接关闭容器
	docker restart 容器id：重启容器
	docker exec -it 容器id /bin/bash ：进入容器
	exit:退出容器
	docker rmi 镜像id:删除镜像
	docker save alpine:latest -o /tmp/alpine.tar 导出镜像
	docker load -i /tmp/alpine.tar	导入镜像
	docker search tomcat ：搜索镜像
	docker pull tomcat:8.5.32：下载指定版本镜像
	docker run --name MYTOMCAT -d tomcat:8.5.32：运行镜像，创建容器，指定name，并后台运行
	端口映射：
	docker run --name myTtomcat1 -d -p 8080:8080 tomcat_centos:jin
	docker run --name myTtomcat2 -d -p 8090:8080 tomcat_centos:jin
	docker cp supportPlatform.war 3666bccf5833:/root：从主机复制文件到容器内
	docker logs containerid：查看容器日志
	docker run -d mysql-57-centos7:latest /bin/sh -c "while true; do echo hello world; sleep 1; done"	：启动容器，并每秒打印一次helloWorld
	docker logs -f  4747d533ef81：查看每秒打印的helloworld
	docker build -t friendlyhello .		：创建一个docker镜像 -t指定名称
	docker pull 10.251.26.11:5000/data_internet_white_list1:191106
	docker push 10.135.6.217:5000/newmodel:191120
	实时查看docker容器日志
	docker logs -f -t --tail 行数 容器名
```



### 清理资源

#### 系统命令

```shell
[root@localhost ~] docker system df	-- 提供Docker整体磁盘使用率的概况，包括镜像、容器和（本地）volume
[root@localhost ~] docker system events
[root@localhost ~] docker system info
[root@localhost ~] docker system prune -- 清理docker占用资源，
WARNING! This will remove:
        - all stopped containers # 清理停止的容器
        - all networks not used by at least one container #清理没有使用的网络
        - all dangling images #清理废弃的镜像
        - all build cache #清理构建缓存
Are you sure you want to continue? [y/N] y


```


#### 镜像清理

```shell
[root@localhost ~] docker image prune --filter "until=24h"	-- 清理24小时前的虚悬镜像（none 对象）
[root@localhost ~] docker image prune -a --filter "until=24h" -- 清理24小时前的无容器使用镜像（
```



#### 修剪容器

```sh
[root@localhost ~] docker container prune -- 清理容器， 强制添加-f
```





### docker更改时区的问题

	docker更改时区的问题：创建服务容器时，可以在dockerfile文件里添加环境变量达到同步时间的目的
	对已经运行的容器，并且不方便停止时。可将宿主机上的/usr/share/zoneinfo/Asia/Shanghai文件复制到容器内：
	docker cp /usr/share/zoneinfo/Asia/Shanghai 9d967517ff48:/etc/localtime
	
	当用镜像通过run来创建容器时：后台的标准操作：
		1.检查镜像在本地是否存在，不存在，就从公有库下载
		2.利用镜像创建容器
		3.分配文件系统，并在只读的镜像层外面挂载一层可读写层
		4.从宿主机配置的网桥接口中桥接一个虚拟接口到容器
		5.从地址池配置一个ip地址给容器
		6.执行用户指定的应用程序
		7.执行完毕后容器被终止

```

当容器被改变后，比如安装了jdk或者添加了python3开发环境等类似情况，可以使用docker commit命令提交更新后的副本。
-m：指定提交的说明信息
-a：指定更新的用户信息
docker commit -m "ADD PYTHON3" -a "docker newbee" 容器ID
	
启动容器并使用-v将war包挂载到容器内tomcat目下的webapps目录下，运行war包。-v挂载单个文件
docker run -d -p 10001:8080 -v /app/JinDocker/tomcatDocker/tomcatAP/webapps/supportPlatform.war:/app/tomcat/webapps/supportPlatform.war --name Mytomcat2 tomcat:latest
		
启动容器并使用-v将war包挂载到容器内tomcat目下的webapps目录下，运行war包。并将目录挂载到容器的日志目录，将日志映射到宿主机上的目录。
docker run -d -p 10004:8080 -v /app/JinDocker/tomcatDocker/tomcatAP/webapps/supportPlatform.war:/app/tomcat/webapps/supportPlatform.war -v /home/was/logs/:/app/tomcat/logs  --name Mytomcat4 tomcat:latest

从容器cp文件到宿主机
docker cp <containerId>:/file/path/within/container /host/path/target  

创建一个swarm集群：docker swarm init
向集群添加一个服务：docker service create --replicas 1 --name "服务名"  "镜像名"
当前节点离开集群：docker swarm leave --force
在管理机上删除某一个work节点：docker node rm -f <node>
查看服务的日志：docker service logs 服务ID
查看集群中的服务：docker service ls
查看具体某一个服务：docker service ps 服务名	查看时进行过滤：docker service ps -f "desired-state=running" 服务名
删除某一个服务：docker service rm 服务名
向集群添加一个worker节点：docker swarm join --token  集群ID managerIP：port	
查看token的方法：docker swarm join-token worker
向集群添加一个manager节点，现在leader节点上执行：docker swarm join-token manager，查看管理节点加入需要的token
查看集群中的所有节点：docker node ls  
节点降级，由管理节点降级为工作节点：docker node demote	要降级的节点名
节点升级，在leader节点执行，由工作节点升级为管理节点：docker node promote 要升级的节点名
更新节点：docker node update
查看节点中的任务：docker node ps
查看服务详情：docker service inspect 服务名
查看所有服务：docker service ls  
更新一个服务:docker service update	
一般用于更新状态或者增加服务参数：docker service update --args "ping www.baidu.com" hello 给名为hello的服务添加任务访问百度
设置某个服务个数:docker service scale 数量		给服务增加副本数量：docker service scale 服务名=4
docker system prune 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。
docker system prune -a 命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。
注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了,慎重使用。
重启docker服务：systemctl restart docker
将管理节点上的任务转移到其他节点：docker node update --availability drain nodeName
取消上述操作：docker node update --availability active nodeName
重构docker集群（慎用）：docker swarm init --force-new-cluster
docker swarm update --snapshot-interval 1000

docker stats：查看机器内容器的使用状态，每秒刷新一次
docker stats --no-stream：查看机器当前容器的资源使用状态
docker stats --no-stream 69f86f5d7019 56cc57105c96：查看指定容器的资源情况，多个容器之间用空格隔开


docker是创建容器的工具，一个容器创建出来是虚拟了一套操作系统，一台真实的物理机里可以创建出若干个容器。

docker创建某个容器的前提是有镜像，docker是根据镜像来创建容器的。如果本地没有镜像，docker会从仓库拉取。

swarm是可以将多个docker主机组成的系统转换为单一的虚拟docker主机，使得容器可以组成跨主机的子网网络。
swarm是管理docker集群，它将一群docker宿主机变成一个单一的，虚拟的主机。


滚动更新服务
docker service update --image swarm_support:new --update-failure-action continue  swarm_support_3


数据卷是一个可供容器使用的特殊目录，它绕过文件系统，类似linux下的挂载，有很多特性：
1.数据卷可以在容器之间共享和重用
2.对数据卷的修改会立马生效
3.对数据卷的更新，不会影响镜像
4.卷会一直存在，直到没有容器

创建数据卷：使用-v参数可以在容器内创建一个数据卷，多次使用-v可以创建多个数据卷


容器的迁移：
第一步：备份：会生成一个容器的镜像快照，通过查看镜像的命令可以查看该快照。后面的操作我不说你也明白
	docker commit -p 30b8f18f20b4 container-backup

curl -X POST -H 'Content-Type: application/json;charset=UTF-8' -i 'http://172.16.50.216:9999/coolq/send_group_msg_rate_limited' --data '{"group_id":"992482224","message":"我又回\n来了"}'

数据卷容器是一个普通的容器，创建一个数据卷容器，并在其中创建一个数据卷挂载到/dbdata：
docker run -d -v /dbdata --name datajuan tomcat:latest

然后可以使用–volumes-form来挂载datajuan容器中的数据卷，例如创建Mytomcat1和Mytomcat2容器：
docker run -d --volumes-from datajuan --name Mytomcat2 tomcat:latest
docker run -d --volumes-from datajuan --name Mytomcat1 tomcat:latest

此时容器Mytomcat2和Mytomcat1都挂载同一个数据卷到相同的/dbdata目录，三个容器任何一方在该目录下写入，其他容器都能看到。
可以使用–volumes-from参数，从多个容器挂载多个数据卷，还可以从其他已经挂载了数据卷的容器来挂载数据卷：
docker run -d --volumes-from Mytomcat2 --name Mytomcat3 tomcat:latest：启动Mytomcat3容器，从已经挂载数据卷的容器Mytomcat2挂载数据卷，
它们四个容器之间/dbdata目录是完全同步的。


数据卷的备份：如果想要备份上述容器中的数据卷：新创建一个容器work，并且使用--volumes-from参数让work容器挂载Mytomcat1容器，也就是挂载其数据卷，使用-v参数，
将backup目录挂载至本机目录，然后容器启动后，使用tar cvf /backup/backup.tar /dbdata，将dbdata目录下的内容打包备份到backup下，在宿主机的/app/shujujuan
目录下即可看到备份数据
docker run --volumes-from Mytomcat1 -v /app/shujujuan:/backup --name worker tomcat:latest tar cvf /backup/backup.tar /dbdata

恢复数据：
tar xvf /backup/backup.tar



集群方式启动，并将输出日志挂载到本机目录下。本机目录需确保有
docker service create --replicas 3 --mount type=bind,src=/home/was/mount/,dst=/app/tomcat/logs --name "swarm_mout" "swarm_support"


brctl show #查看bridge网络


1.加载新镜像
2.滚动更新服务

1.data_internet_white_list ：8840
	docker service update --image data_internet_white_list:190919 --update-failure-action continue data_internet_white_list
	
2.data_membership_center ：8820
	docker service update --image data_membership_center:190919 --update-failure-action continue data_membership_center
	
3.data_order_marking ：8810
	docker service update --image data_order_marking:190919 --update-failure-action continue data_order_marking
	
4.data_channel_punch ：8830
	docker service update --image data_channel_punch:190919 --update-failure-action continue data_channel_punch


docker service create --replicas 3 --mount type=bind,src=/app/dockerservice/data_order_marking/logs/,dst=/app/tomcat/logs --name "data_order_marking" "data_order_marking


docker service create --replicas 20 -p 8840:8840  --mount type=bind,src=/app/newmodel/logs/,dst=/app/tomcat/logs --name "newmodel" "10.135.6.217:5000/newmodel:191120"

docker service update --reserve-memory {内存使用} {服务名字}

docker service create --replicas 5 -p 8820:8820 --mount type=bind,src=/app/data_membership_center/logs/,dst=/logs/data_membership_center/ --name "data_membership_center" "data_membership_center:190718"

docker service create --replicas 5 -p 8820:8820 --limit-memory 2G  --mount type=bind,src=/app/data_membership_center/logs/,dst=/logs/data_membership_center/ --name "data_membership_center" "data_membership_center:190718"

docker service update --image data_internet_white_list:190806 --update-failure-action continue data_internet_white_list

docker service create --replicas 3  --limit-memory 2G  --mount type=bind,src=/app/channel_whitelist/logs/,dst=/logs/ --name "channel_whitelist" "channel_whitelist:190722"

```



## 遇到问题

### 镜像无curl工具问题

#### 背景

> java:openjdk-8-jre-alpine 镜像中无curl工具，导致健康检查失败

#### 解决

dockerfile文件中添加`RUN apk --no-cache add curl` 步骤

示例

```dockerfile
FROM java:openjdk-8-jre-alpine

ENV APP_NAME foreign-api-1.0-SNAPSHOT
ENV BUILD_ENV ashsh_dev
ENV LOCAL_PATH /opt/${APP_NAME}

RUN mkdir -p ${LOCAL_PATH}
RUN apk --no-cache add curl

ADD target/${APP_NAME}.jar ${LOCAL_PATH}

WORKDIR ${LOCAL_PATH}

CMD java  -Xms800m -Xmx1662m -XX:PermSize=256m -XX:MaxPermSize=1024m -XX:MaxNewSize=1024m -jar ${APP_NAME}.jar --spring.cloud.nacos.config.namespace=${BUILD_ENV}
```



### 打包导出excel字体not found

#### 背景

打包服务设计excel导出， docker打包后服务运行导出excel接口报错

#### 解决

dockerfile文件中添加`RUN apk --no-cache add ttf-dejavu fontconfig` 步骤

```dockerfile
RUN apk --no-cache add curl ttf-dejavu fontconfig
```



### 证书过期 【x509: certificate has expired or is not yet valid】

#### 重新生成证书

```sh
#查看证书是否过期（一年期限，过期了）
root@harbor:/data/harbor/certs# openssl x509 -in /data/harbor/certs/ca.crt -noout -dates
notBefore=Aug 21 01:26:07 2019 GMT
notAfter=Aug 21 01:26:07 2020 GMT
root@harbor:~#cd /data/harbor/certs/
#创建你自己的CA证书
root@harbor:/data/harbor/certs# openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 3650 -out ca.crt -subj "/C=CN/L=gd/O=gz/CN=172.19.166.202"
#创建证书签名请求
root@harbor:/data/harbor/certs# openssl req -newkey rsa:4096 -nodes -sha256 -keyout 172.19.166.202.key -out 172.19.166.202.csr -subj "/C=CN/L=gd/O=gz/CN=172.19.166.202"
#FQDN方式生成注册表主机的证书
root@harbor:/data/harbor/certs# echo subjectAltName = IP:172.19.166.202 > extfile.cnf
root@harbor:/data/harbor/certs# openssl x509 -req -days 3650 -in 172.19.166.202.csr -CA ca.crt -CAkey ca.key -CAcreateserial -extfile extfile.cnf -out 172.19.166.202.crt
#将服务端的 crt 转换成客户端用的 cert
root@harbor:/data/harbor/certs# openssl x509 -inform PEM -in 172.19.166.202.crt -out 172.19.166.202.cert
#查看生成的所有文件
root@harbor:/data/harbor/certs# ls
172.19.166.202.cert  172.19.166.202.crt  172.19.166.202.csr  172.19.166.202.key  ca.crt  ca.key  ca.srl  extfile.cnf
```



#### 复制证书至操作机器

```s
[root@rancherserver2 ~]# rsync -av ashsh@172.19.166.202:/etc/docker/certs.d/ /etc/docker/certs.d/
[root@rancherserver2 ~]# ls /etc/docker/certs.d/172.19.166.202/
server.crt  ca.crt
[root@rancherserver2 ~]# systemctl restart docker 
```



#### 如果还是失效， 检查docker.service

查看`--insecure-registry`是否有配置，地址是否为私仓地址, 不是则调整

```sh
# 查看docker配置
[ashsh@test-data-sh002 ~]$ sudo cat /etc/systemd/system/docker.service
[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=172.19.0.149

# 调整私服地址
[ashsh@test-data-sh002 ~]$ sudo vim /etc/systemd/system/docker.service
[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=172.19.166.202

# 加载配置重启docker服务
[ashsh@test-data-sh002 ~]$ sudo systemctl daemon-reload
[ashsh@test-data-sh002 ~]$ sudo systemctl restart docker 
```





# Docker Swarm



## 操作

### 服务操作

| 命令                  | 描述                       | 示例                                                         |
| --------------------- | -------------------------- | ------------------------------------------------------------ |
| docker stack deploy   | 部署新的堆栈或更新现有堆栈 | docker stack deploy ${stackName} --compose-file ${配置yaml}<br />例：<br/>$: docker stack deploy prom --compose-file docker-stack.yml |
| docker stack ls       | 列出堆栈中的任务           |                                                              |
| docker stack ps       | 列出现有堆栈               | docker stack ps ${堆栈名}<br />例：<br />docker stack ps prom |
| docker stack rm       | 删除堆栈                   | docker stack rm ${堆栈名}<br />例:<br />docker stack rm prom |
| docker stack services | 列出堆栈中的服务           | docker stack services ${堆栈名}<br />例：<br />docker stack services jenkins |
| docker service update | 更新服务                   | docker service update ${服务名}<br />例：<br />docker service update prom_prometheus |





### 节点操作

> 所有的active节点，都可以接收task。有时候会遇到，一个节点需要维护暂时不能使用，这意味着此节点将不能再接受新的task，且原有的task也要迁走，在其他可用的节点上运行
>
> 【注】将节点设置为DRAIN并不会从该节点删除独立容器（docker run/ docker up/ docker Engine API创建的容器）。节点的状态只影响service

#### 清空节点

```shell
$: docker node update --availability drain ${节点名}

# 例如： 清空node1中的服务
$: docker node update --availability drain node1 
```

#### 检查节点可用性

```shell
# 检查节点可用性
$ docker node inspect --pretty ${节点名}

# 例
$ docker node inspect --pretty node1
ID:			28t3r12oxo2k9derz8i7yxw7p
Hostname:              	node1
Joined at:             	2019-06-08 12:20:34.266379324 +0000 utc
Status:
 State:			Ready
 Availability:         	Drain
 Address:		192.168.229.128
...
```









## 遇到问题

### Docker swarm 启动服务失败查看日志

运行命令：

> docker service ps --no-trunc {serviceName}





# Docker-compose

### 参数介绍

```yml
常用参数：
    version           # 指定 compose 文件的版本
    services          # 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称
 
        build                 # 与image二选一，指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值
            context               # context: 指定 Dockerfile 文件所在的路径
            dockerfile            # dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)
            args                  # args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)
            cache_from            # v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)
            labels                # v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)
            shm_size              # v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)
 
        command               # 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式
 
        configs               # 不知道怎么用
 
        cgroup_parent         # 为容器指定父 cgroup 组，意味着将继承该组的资源限制。
 
        container_name        # 指定容器的名称 (等同于 docker run --name 的作用)
 
        deploy                # v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm
            endpoint_mode         # v3.3 版本中新增的功能, 指定服务暴露的方式
                vip                   # Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址
                dnsrr                 # DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址
            labels                # 指定服务的标签，这些标签仅在服务上设置
            mode                  # 指定 deploy 的模式
                global                # 每个集群节点都只有一个容器
                replicated            # 用户可以指定集群中容器的数量(默认)
            placement             # 不知道怎么用
            replicas              # deploy 的 mode 为 replicated 时, 指定容器副本的数量
            resources             # 资源限制
                limits                # 设置容器的资源限制
                    cpus: "0.5"           # 设置该容器最多只能使用 50% 的 CPU
                    memory: 50M           # 设置该容器最多只能使用 50M 的内存空间
                reservations          # 设置为容器预留的系统资源(随时可用)
                    cpus: "0.2"           # 为该容器保留 20% 的 CPU
                    memory: 20M           # 为该容器保留 20M 的内存空间
            restart_policy        # 定义容器重启策略, 用于代替 restart 参数
                condition             # 定义容器重启策略(接受三个参数)
                    none                  # 不尝试重启
                    on-failure            # 只有当容器内部应用程序出现问题才会重启
                    any                   # 无论如何都会尝试重启(默认)
                delay                 # 尝试重启的间隔时间(默认为 0s)
                max_attempts          # 尝试重启次数(默认一直尝试重启)
                window                # 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)
            update_config         # 用于配置滚动更新配置
                parallelism           # 一次性更新的容器数量
                delay                 # 更新一组容器之间的间隔时间
                failure_action        # 定义更新失败的策略
                    continue              # 继续更新
                    rollback              # 回滚更新
                    pause                 # 暂停更新(默认)
                monitor               # 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)
                max_failure_ratio     # 回滚期间容忍的失败率(默认值为0)
                order                 # v3.4 版本中新增的参数, 回滚期间的操作顺序
                    stop-first            #旧任务在启动新任务之前停止(默认)
                    start-first           #首先启动新任务, 并且正在运行的任务暂时重叠
            rollback_config       # v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略
                parallelism           # 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚
                delay                 # 每个组回滚之间的时间间隔(默认为0)
                failure_action        # 定义回滚失败的策略
                    continue              # 继续回滚
                    pause                 # 暂停回滚
                monitor               # 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)
                max_failure_ratio     # 回滚期间容忍的失败率(默认值0)
                order                 # 回滚期间的操作顺序
                    stop-first            # 旧任务在启动新任务之前停止(默认)
                    start-first           # 首先启动新任务, 并且正在运行的任务暂时重叠
               
            注意：
                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项
                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent
                network_mode  external_links  restart  build  userns_mode  sysctls
 
        devices               # 指定设备映射列表 (等同于 docker run --device 的作用)
 
        depends_on            # 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)
            示例：
                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动
                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系
 
                version: '3'
                services:
                    web:
                        build: .
                        depends_on:
                            - db     
                            - redis 
                    redis:
                        image: redis
                    db:
                        image: postgres                            
 
        dns                   # 设置 DNS 地址(等同于 docker run --dns 的作用)
 
        dns_search            # 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)
 
        tmpfs                 # v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)
 
        entrypoint            # 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)
 
        env_file              # 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值
            文件格式：
                RACK_ENV=development
 
        environment           # 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)
 
        expose                # 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令
 
        external_links        # 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)
 
        extra_hosts           # 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)
 
        healthcheck           # v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令
            test                  # 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串
                NONE                  # 禁用容器的健康状态检测
                CMD                   # test: ["CMD", "curl", "-f", "http://localhost"]
                CMD-SHELL             # test: ["CMD-SHELL", "curl -f http://localhost || exit 1"] 或者　test: curl -f https://localhost || exit 1
            interval: 1m30s       # 每次检查之间的间隔时间
            timeout: 10s          # 运行命令的超时时间
            retries: 3            # 重试次数
            start_period: 40s     # v3.4 以上新增的选项, 定义容器启动时间间隔
            disable: true         # true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同
         
        image                 # 指定 docker 镜像, 可以是远程仓库镜像、本地镜像
 
        init                  # v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程
 
        isolation             # 隔离容器技术, 在 Linux 中仅支持 default 值
 
        labels                # 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似
 
        links                 # 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)
         
        logging               # 设置容器日志服务
            driver                # 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)
            options               # 指定日志的相关参数 (等同于 docker run --log-opt 的作用)
                max-size              # 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作
                max-file              # 日志文件保留的数量
 
        network_mode          # 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)        
 
        networks              # 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键
            aliases               # 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器
            ipv4_address      # IP V4 格式
            ipv6_address      # IP V6 格式
 
            示例:
                version: '3.7'
                services:
                    test:
                        image: nginx:1.14-alpine
                        container_name: mynginx
                        command: ifconfig
                        networks:
                            app_net:                                # 调用下面 networks 定义的 app_net 网络
                            ipv4_address: 172.16.238.10
                networks:
                    app_net:
                        driver: bridge
                        ipam:
                            driver: default
                            config:
                                - subnet: 172.16.238.0/24
 
        pid: 'host'           # 共享宿主机的 进程空间(PID)
 
        ports                 # 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式
            SHORT 语法格式示例:
                - "3000"                            # 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口
                - "3000-3005"                       # 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口
                - "8000:8000"                       # 容器的 8000 端口和宿主机的 8000 端口建立映射关系
                - "9090-9091:8080-8081"
                - "127.0.0.1:8001:8001"             # 指定映射宿主机的指定地址的
                - "127.0.0.1:5000-5010:5000-5010"  
                - "6060:6060/udp"                   # 指定协议
 
            LONG 语法格式示例:(v3.2 新增的语法格式)
                ports:
                    - target: 80                    # 容器端口
                      published: 8080               # 宿主机端口
                      protocol: tcp                 # 协议类型
                      mode: host                    # host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡
 
        secrets               # 存储敏感数据，例如密码
 
        security_opt          # 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)
 
        stop_grace_period     # 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)
 
        stop_signal           # 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)
 
        sysctls               # 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)
 
        ulimits               # 设置容器的 limit
 
        userns_mode           # 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)
 
        volumes               # 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用
            SHORT 语法格式示例:
                volumes:
                    - /var/lib/mysql                # 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中
                    - /opt/data:/var/lib/mysql      # 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data
                    - ./cache:/tmp/cache            # 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置
                    - ~/configs:/etc/configs/:ro    # 映射容器宿主机的目录到容器中去, 权限只读
                    - datavolume:/var/lib/mysql     # datavolume 为 volumes 顶级键定义的目录, 在此处直接调用
             
            LONG 语法格式示例:(v3.2 新增的语法格式)
                version: "3.2"
                services:
                    web:
                        image: nginx:alpine
                        ports:
                            - "80:80"
                        volumes:
                            - type: volume                  # mount 的类型, 必须是 bind、volume 或 tmpfs
                                source: mydata              # 宿主机目录
                                target: /data               # 容器目录
                                volume:                     # 配置额外的选项, 其 key 必须和 type 的值相同
                                    nocopy: true                # volume 额外的选项, 在创建卷时禁用从容器复制数据
                            - type: bind                    # volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径
                                source: ./static
                                target: /opt/app/static
                                read_only: true             # 设置文件系统为只读文件系统
                volumes:
                    mydata:                                 # 定义在 volume, 可在所有服务中调用
                 
        restart               # 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)
            no                    # 禁止自动重启容器(默认)
            always                # 无论如何容器都会重启
            on-failure            # 当出现 on-failure 报错时, 容器重新启动
 
        其他选项：
            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir
            上面这些选项都只接受单个值和 docker run 的对应参数类似
 
        对于值为时间的可接受的值：
            2.5s
            10s
            1m30s
            2h32m
            5h34m56s
 
            时间单位: us, ms, s, m， h
 
        对于值为大小的可接受的值：
            2b
            1024kb
            2048k
            300m
            1gb
 
            单位: b, k, m, g 或者 kb, mb, gb
 
 
    networks          # 定义 networks 信息
        driver                # 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上
            bridge                # Docker 默认使用 bridge 连接单个主机上的网络
            overlay               # overlay 驱动程序创建一个跨多个节点命名的网络
            host                  # 共享主机网络名称空间(等同于 docker run --net=host)
            none                  # 等同于 docker run --net=none
 
        driver_opts           # v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序
 
        attachable            # driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信
 
        ipam                  # 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的
            driver                # IPAM 驱动程序, bridge 或者 default
            config                # 配置项
                subnet                # CIDR格式的子网，表示该网络的网段
         
        external              # 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误
 
        name                  # v3.5 以上版本, 为此网络设置名称
     
 
 
文件格式示例：
    version: "3"
    services:
 
      redis:
        image: redis:alpine
        ports:
          - "6379"
        networks:
          - frontend
        deploy:
          replicas: 2
          update_config:
            parallelism: 2
            delay: 10s
          restart_policy:
            condition: on-failure
 
      db:
        image: postgres:9.4
        volumes:
          - db-data:/var/lib/postgresql/data
        networks:
          - backend
        deploy:
          placement:
            constraints: [node.role == manager]
```

