# Java与协程

协程（Coroutines）是一种轻量级的多任务处理方式，它与线程类似，但是相比于线程，协程更加轻量且更容易控制。协程允许程序在一个特定的位置挂起执行，并在需要的时候恢复执行，从而实现在同一个线程中看似同时执行多个任务的效果。

与传统的多线程或多进程编程相比，协程具有以下几个显著的特点：

1. 协程是用户级的，不依赖于操作系统的线程或进程。它由编程语言或运行时库提供支持，因此可以在不同的操作系统上运行，并且在不同的语言中有不同的实现。
2. 协程可以在同一个线程中切换执行上下文，因此它们的创建和销毁开销较小，且不涉及操作系统的线程切换。
3. 协程可以通过挂起和恢复操作来实现协作式多任务处理。当一个协程遇到挂起点（例如等待I/O操作完成），它会将执行控制权交还给调度器，允许其他协程继续执行。当等待的条件满足时，该协程可以恢复执行。
4. 协程可以在同一个线程中共享数据，因此不需要像多线程编程那样担心共享数据的同步问题。这使得协程编程更加容易理解和调试。

协程通常用于处理I/O密集型任务，例如网络编程、文件读写等场景，因为在这些任务中，大部分时间都花费在等待I/O操作完成上。协程可以高效地挂起等待，而不是浪费线程等待。使用协程可以编写更加简洁、高效的异步代码，提高程序的性能和可维护性。

需要注意的是，协程的实现方式因编程语言和运行时环境而异。不同的语言可能会提供不同的协程机制和语法。例如，Python中有Generator-based协程，C#中有async/await异步编程模型，而在一些其他语言中可能会有更加灵活和定制化的协程支持。

### 有栈协程

> 有栈协程是一种协程实现方式，它类似于线程，每个有栈协程都有自己的执行栈。当有栈协程被挂起（暂停执行）时，其执行栈的状态被保存，包括局部变量和函数调用栈。当有栈协程被重新恢复执行时，它的执行栈状态会被还原，继续执行挂起的地方。

这种有栈协程的实现方式使得它们可以在挂起和恢复时保持函数调用的上下文，因此有栈协程可以执行更复杂的逻辑。然而，由于每个有栈协程都需要独立的执行栈，协程的创建和销毁可能会更加昂贵，也更容易出现栈溢出等问题。

### 无栈协程

> 无栈协程是一种协程实现方式，它没有自己的执行栈。相反，它们共享一个或多个执行栈。当一个无栈协程被挂起时，它的执行状态会被保存在其他地方，而不是保存在自己的执行栈中。当该协程被重新恢复时，它的执行状态会被还原到之前的状态。

由于无栈协程共享执行栈，它们的创建和销毁开销较小，并且在内存消耗上也相对较少。然而，由于没有独立的执行栈，无栈协程可能不能像有栈协程那样轻松地处理函数调用和局部变量。

### 总结

总体而言，有栈协程和无栈协程各有优势和劣势，具体的使用取决于应用场景和需求。有栈协程适用于执行较为复杂的任务，而无栈协程适用于需要大量协程且需要较小内存开销的场景。很多编程语言和运行时环境提供了协程的支持，并可以选择适合自己需求的实现方式。

### 扩展：java的解决方案-Loom

项目地址： [loom](https://github.com/openjdk/loom)

Loom是OpenJDK社区中的一个项目，旨在向Java平台引入原生的轻量级线程（lightweight threads），以实现更高效的并发编程。它是Java平台（JVM）的一项重要改进，旨在解决现有Java线程模型的一些局限性，并提供更好的协程支持。

在传统的Java线程模型中，每个线程都会映射到操作系统的原生线程，创建和销毁线程的开销较大，且线程之间的切换需要涉及操作系统的调度。这导致在高并发场景下，创建大量线程可能会导致系统资源耗尽，同时线程切换也会带来一定的开销。

Loom引入的轻量级线程是基于协程的概念实现的。它们被称为**"Virtual Threads"（虚拟线程）或"Project Loom Threads"（Loom线程）**。与传统的Java线程不同，Loom线程不会直接映射到操作系统的线程，而是由Java虚拟机和运行时库在用户空间进行调度和管理。

Loom的目标是提供以下优势：

1. 更高效的并发：由于Loom线程是轻量级的，创建和销毁开销较小，且可以在更少的系统线程上执行大量的Loom线程，从而提高系统的并发性能。
2. 更低的内存消耗：相比于传统的Java线程，Loom线程占用更少的内存，因为它们不需要独立的栈和线程控制块。
3. 更好的协程支持：Loom的目标之一是使协程变得更容易使用和管理。它将提供更加简洁的API来实现协程，使开发者能够轻松地编写异步和并发的代码。
4. 更好的可扩展性：Loom线程的轻量级特性使得它们更适合处理大规模并发场景，特别是在高并发的Web服务器等应用中，可以显著提升系统的可扩展性。

Loom项目在Java 17版本中开始进行逐步开放，它是Java生态系统中一项重要的改进

